
**1 目标**
* `keep-alive`
* 组件的封装与继承

**2 笔记**
* `keep-aliv`  
  **简介**  
    > * 使组件切换过程中将状态保留在内存中，防止重复渲染DOM  
    >> * 包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们  
    >> * 他自身不会渲染一个`DOM`元素，也不会出现在父组件链中  

  **`prop`**  
    > * 属性  
    >> * `include`：字符串或正则表达式。只有匹配的组件会被缓存  
    >> * `exclude`：字符串或正则表达式。任何匹配的组件都不会被缓存  

  **生命周期函数**  
    > * `activated`：组件第一次渲染会被调用，之后在每次缓存被激活时调用  
    > * `deactivated`：组件被停用（离开路由）时调用  

  **原理**  
    > * 在`created`时将需要缓存的`VNode`节点保存在`this.cache`中  
    > * 在`render`时，如果`VNode`的`name`符合在缓存条件(可以用`include`以及`exclude`)，则会从`this.cache`中取出之前缓存的`VNode`实例进行渲染  

  **源码分析**  
    > * `created`：会创建一个`cache`对象，用来作为缓存容器，保存`VNode`节点  
    > * `destroyed`：在组件被销毁的时候清除`cache`缓存中的所有组件实例  

* 组件的封装与继承  
  **组件封装的优点**
    > * 符合`vue`的核心之————组件化  
    > * 简化了界面，方便维护  
    > * 提高复用性，减少代码量

  **如何进行封装**
    > * 新建组件，处理好组件内部的逻辑  
    > * 与父组件建立通讯关系  
    > * 父组件调用，返回值给父组件  

  **组件继承————`minxins`**
    > * 类型：`Array<Object>`  
    > * 详细：`mixins`选项接受一个混入对象的数组。这些混入实例对象可以像正常的实例对象一样包含选项，它们将在`Vue.extend()`里最终选择使用相同的选项合并逻辑合并。
    > * 举例：如果你的混入包含一个钩子，而创建组件本身也有一个，两个函数将被调用。  
    > * `Mixin`钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。

  **组件继承————`extends`**
    > * 类型：`Object| Function`  
    > * 详细：允许声明扩展一个组件(可以是一个简单的选项对象或构造函数)，而无需使用`Vue.extend`。这主要是为了便于扩展但文件组件。

  **小结**
    > * 特点：优先调用`mixins`和`extends`继承的父类，`extends`触发的优先级更高  
    > * 使用场景：在某种功能完善的公用组件上，对组件进行扩展时，会用到`extend`，而不需要重新写一个组件。  

  **注意**
    > * `mixins`类似于面向切面的编程(`AOP`)，`mixins`可以混入多个`mixin`  
    > * `extends`类型于面向对象的编程，`extends`只能继承一个  
    > * 优先级：`vue.extend` > `extends` > `mixins`  

**3 问题库**